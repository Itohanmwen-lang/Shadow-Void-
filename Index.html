<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Shadow Void: Omni-Action</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: -apple-system, sans-serif; touch-action: none; }
        canvas { display: block; }
        #dashboard {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; background: rgba(15, 15, 15, 0.9);
            padding: 12px; border-radius: 20px; border: 1px solid #333; z-index: 10;
        }
        .btn {
            color: #fff; font-size: 10px; padding: 8px; border: 1px solid #444; border-radius: 10px;
            text-align: center; min-width: 50px; cursor: pointer;
        }
        .active { background: #fff; color: #000; border-color: #fff; }
        #status { position: absolute; top: 40px; left: 20px; color: #666; font-size: 10px; letter-spacing: 1px; pointer-events: none; }
        b { color: #fff; }
    </style>
</head>
<body>

<div id="status">MODE: <b id="mode-label">SPAWN</b> | GRAVITY: <b id="grav-label">9.8</b></div>

<div id="dashboard">
    <div id="btn-spawn" class="btn active" onclick="setMode('spawn')">‚ûï<br>SPAWN</div>
    <div id="btn-weld" class="btn" onclick="setMode('weld')">üîó<br>WELD</div>
    <div id="btn-heat" class="btn" onclick="setMode('heat')">üî•<br>HEAT</div>
    <div id="btn-blast" class="btn" onclick="triggerExplosion()">üí•<br>BLAST</div>
    <div id="btn-grav" class="btn" onclick="toggleGrav()">ü™ê<br>GRAV</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
    const { Engine, Render, Runner, Bodies, Composite, Constraint, Mouse, MouseConstraint, Vector, Body } = Matter;
    const engine = Engine.create();
    const world = engine.world;
    const render = Render.create({ element: document.body, engine: engine, options: { width: window.innerWidth, height: window.innerHeight, wireframes: false, background: '#000' }});
    
    Render.run(render);
    Runner.run(Runner.create(), engine);

    // World Walls
    const wallOpts = { isStatic: true, render: { visible: false } };
    Composite.add(world, [
        Bodies.rectangle(window.innerWidth/2, window.innerHeight+50, window.innerWidth, 100, wallOpts),
        Bodies.rectangle(-50, window.innerHeight/2, 100, window.innerHeight, wallOpts),
        Bodies.rectangle(window.innerWidth+50, window.innerHeight/2, 100, window.innerHeight, wallOpts),
        Bodies.rectangle(window.innerWidth/2, -50, window.innerWidth, 100, wallOpts)
    ]);

    let currentMode = 'spawn';
    let weldTarget = null;

    function setMode(m) {
        currentMode = m;
        document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
        document.getElementById('btn-' + m).classList.add('active');
        document.getElementById('mode-label').innerText = m.toUpperCase();
    }

    // Interactive Logic
    window.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        const pos = { x: touch.clientX, y: touch.clientY };
        const found = Matter.Query.point(Composite.allBodies(world), pos)[0];

        if (currentMode === 'spawn' && !found) {
            const b = Bodies.rectangle(pos.x, pos.y, 40, 40, { 
                restitution: 0.5, 
                render: { fillStyle: '#111', strokeStyle: '#fff', lineWidth: 1 } 
            });
            b.health = 100; // Destruction tracking
            b.temp = 0;    // Heat tracking
            Composite.add(world, b);
        } else if (currentMode === 'weld' && found) {
            if (!weldTarget) {
                weldTarget = found;
                found.render.strokeStyle = '#00ff00';
            } else {
                if (weldTarget !== found) {
                    const c = Constraint.create({ bodyA: weldTarget, bodyB: found, stiffness: 0.2, render: { strokeStyle: '#444' }});
                    Composite.add(world, c);
                }
                weldTarget.render.strokeStyle = '#fff';
                weldTarget = null;
            }
        }
    });

    // Destruction & Heat Loop
    Matter.Events.on(engine, 'beforeUpdate', () => {
        const bodies = Composite.allBodies(world);
        bodies.forEach(b => {
            if (b.isStatic) return;
            // Destruction logic: Check velocity for "shatter"
            if (b.speed > 15) {
                b.render.fillStyle = '#300'; // Show damage
                if (b.speed > 25) { Composite.remove(world, b); spawnDebris(b.position); }
            }
            // Heat logic
            if (b.temp > 0) {
                b.temp -= 0.1; 
                b.render.fillStyle = `rgb(${Math.min(255, b.temp * 5)}, 20, 20)`;
                if (b.temp > 50) Body.scale(b, 0.99, 0.99); // Melt effect
                if (b.temp > 100) Composite.remove(world, b);
            }
        });
    });

    function spawnDebris(pos) {
        for(let i=0; i<4; i++) {
            Composite.add(world, Bodies.circle(pos.x, pos.y, 5, { render: { fillStyle: '#555' }}));
        }
    }

    // Continuous Heat application
    window.addEventListener('touchmove', (e) => {
        if (currentMode === 'heat') {
            const touch = e.touches[0];
            const found = Matter.Query.point(Composite.allBodies(world), { x: touch.clientX, y: touch.clientY });
            found.forEach(b => { if(!b.isStatic) b.temp += 5; });
        }
    });

    function toggleGrav() {
        world.gravity.y = world.gravity.y === 1 ? -1 : 1;
        document.getElementById('grav-label').innerText = world.gravity.y > 0 ? "9.8" : "-9.8";
    }

    function triggerExplosion() {
        Composite.allBodies(world).forEach(b => {
            if(!b.isStatic) {
                const force = Vector.mult(Vector.normalise(Vector.sub(b.position, {x: window.innerWidth/2, y: window.innerHeight/2})), 0.1 * b.mass);
                Body.applyForce(b, b.position, force);
            }
        });
    }

    const mouse = Mouse.create(render.canvas);
    Composite.add(world, MouseConstraint.create(engine, { mouse: mouse, constraint: { stiffness: 0.1, render: { visible: false }}}));
</script>
</body>
</html>
